<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.revision API documentation</title>
<meta name="description" content="Main class of the module, allowing the user to make the knowledge revision between two `src.formula.formula.Formula`
\(\psi\) and \(\mu\) that are …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.revision</code></h1>
</header>
<section id="section-intro">
<p>Main class of the module, allowing the user to make the knowledge revision between two <code><a title="src.formula.formula.Formula" href="formula/formula.html#src.formula.formula.Formula">Formula</a></code>
<span><span class="MathJax_Preview">\psi</span><script type="math/tex">\psi</script></span> and <span><span class="MathJax_Preview">\mu</span><script type="math/tex">\mu</script></span> that are mixed integer linear constraints.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">r&#34;&#34;&#34;
Main class of the module, allowing the user to make the knowledge revision between two `src.formula.formula.Formula`
\(\psi\) and \(\mu\) that are mixed integer linear constraints.
&#34;&#34;&#34;

from __future__ import annotations

from .formula import Formula, Or, And, UnaryFormula, NullaryFormula, LinearConstraint, Not, ConstraintOperator, PropositionalVariable, EnumeratedType
from .formulaInterpreter import FormulaInterpreter
from .mlo_solver import MLOSolver
from .distance import DistanceFunction
from .constants import Constants
from .simplificator import Simplificator
from .projector import Projector
from .variable import IntegerVariable, RealVariable

from fractions import Fraction
from tqdm import tqdm
import time
from contextlib import ExitStack

import math

class Revision:
    r&#34;&#34;&#34;
    Main class of the module, allowing the user to make the knowledge revision between two `src.formula.formula.Formula`
    \(\psi\) and \(\mu\) that are mixed integer linear constraints.

    Parameters
    ----------
    solverInit : src.mlo_solver.MLOSolver.MLOSolver
        The solver that will be used for optimization.
    distance : src.distance.distance_function.distanceFunction.DistanceFunction
        The distance function that will be used and, more importantly, the weights \((w_i)\) and \(\varepsilon\) arguments of it.
        The original algorithm is meant to be used with a `src.distance.distance_function.discreteL1DistanceFunction.discreteL1DistanceFunction`.
    simplifiers : list of src.simplificator.simplificator.Simplificator, optional
        List of all of the `src.simplificator.simplificator.Simplificator` that will be applied to the `src.formula.formula.Formula`, 
        in order given by the list.
    onlyOneSolution : boolean, optional
        If set to `True`, the revision algorithm will by default only return one point that satisfies \(\psi \circ \mu\).
        If not, it will return all solutions.
        By default, this constant is set to whichever one was chosen in `src.constants.Constants`.
    &#34;&#34;&#34;
    
    __distance : DistanceFunction
    __interpreter : FormulaInterpreter
    __e2bConstraints: set[Formula]
    _onlyOneSolution: bool

    def __init__(self, solverInit : MLOSolver, distance : DistanceFunction, simplifiers : list[Simplificator] = [], onlyOneSolution: bool = Constants.ONLY_ONE_SOLUTION, verbose: bool = Constants.SET_VERBOSE, projector: Projector = None) -&gt; None:        
        self.__distance = distance 
        self.__interpreter = FormulaInterpreter(solverInit, distance, simplifiers)
        self._onlyOneSolution = onlyOneSolution
        self.__verbose = verbose

        self.__e2bConstraints = set()

        self.__projector = projector

    def preload(self):

        weights = self.__distance.getWeights()
        self.boolToInt = dict()

        for var in weights.copy().keys():

            if isinstance(var, PropositionalVariable):
                self.__b2iPreload(var, weights)

            if isinstance(var, EnumeratedType):

                self.__e2bConstraints.add(var.generateConstraints())

                for value in var.values.values():
                    weights[value] = weights[var]
                    self.__b2iPreload(value, weights)

    def __b2iPreload(self, var, weights):

        intVar = IntegerVariable.declare(&#34;b2i_&#34; + var.name, lowerBound=Fraction(0), upperBound=Fraction(1))

        self.boolToInt[var] = intVar
        weights[intVar] = weights[var]

    def execute(self, psi : Formula, mu : Formula) -&gt; tuple[Fraction, Formula]:
        r&#34;&#34;&#34;
        Execute the revision of \(\psi\) by \(\mu\).

        Parameters
        ----------
        psi : src.formula.formula.Formula
            \(\psi\), left part of the knowledge revision operator and `src.formula.formula.Formula` that will be revised.
        mu : src.formula.formula.Formula
            \(\mu\), right part of the knowledge revision operator and `src.formula.formula.Formula` that will be used to revise \(\psi\) by.


        Returns
        -------
        Fraction
            Distance (calculated with the `src.distance.distance_function.distanceFunction.DistanceFunction`
            given at the initialization of the class) between \(\psi\) and \(\mu\).
        src.formula.formula.Formula
            Result of the knowledge revison of \(\psi\) by \(\mu\).
        &#34;&#34;&#34;

        self.__timeStart = time.perf_counter()

        if len(self.__e2bConstraints) &gt;= 1:
            psi &amp;= And(*self.__e2bConstraints)
            mu &amp;= And(*self.__e2bConstraints)

        if self.__verbose:
            print(&#34;\n&#34; + self.getTime(), &#34;Transforming Psi in DNF form&#34;)
        psiDNF = psi.toPCMLC(self.boolToInt).toLessOrEqConstraint().toDNF()

        if self.__verbose:
            print(&#34;\n&#34; + self.getTime(), &#34;Transforming Mu in DNF form&#34;)
        muDNF = mu.toPCMLC(self.boolToInt).toLessOrEqConstraint().toDNF()

        res = self.__executeDNF(self.__convertExplicit(psiDNF), self.__convertExplicit(muDNF))

        if self.__verbose:
            print(&#34;\n&#34; + self.getTime(), f&#34;Solution found with distance of {res[0]}:\n&#34;)
            try:
                self.organizedPrintResult(res[1])
            except:
                print(res[1])

        return res
        
    def __executeDNF(self, psi: Formula, mu: Formula) -&gt; tuple[Fraction, Formula]:
        
        res = None
        disRes = None

        if self.__verbose:
            print(&#34;&#34;)
            psiIter = tqdm(psi.children, desc=f&#34;{self.getTime()} Testing satisfiability of every child of Psi&#34;, mininterval=0.5)
        else:
            psiIter = psi.children

        satPsi = set()
        for miniPsi in psiIter:
            if self.__interpreter.sat(miniPsi):
                satPsi.add(miniPsi)

        if len(satPsi) == 0:
            raise(AttributeError(&#34;Psi is not satisfiable&#34;))

        if self.__verbose:
            print(self.getTime(), f&#34;{len(satPsi)} satisfiable children of Psi found\n&#34;)
            muIter = tqdm(mu.children, desc=f&#34;{self.getTime()} Testing satisfiability of every child of Mu&#34;, mininterval=0.5)
        else:
            muIter = mu.children
            
        satMu = set()
        for miniMu in muIter:
            if self.__interpreter.sat(miniMu):
                satMu.add(miniMu)

        if len(satMu) == 0:
            raise(AttributeError(&#34;Mu is not satisfiable&#34;))

        maxIter = len(satPsi)*len(satMu)

        if self.__verbose:
            print(self.getTime(), f&#34;{len(satMu)} satisfiable children of Mu found&#34;)
            print(&#34;\n&#34; + self.getTime(), f&#34;{maxIter} combinations of conjunctions found&#34;)

        if(self._onlyOneSolution):

            with ExitStack() as stack:

                if self.__verbose:
                    pbar = stack.enter_context(tqdm(total=maxIter, desc=f&#34;{self.getTime()} Revision of every combination&#34;, mininterval=0.5))

                for miniPsi in satPsi:
                    for miniMu in satMu:

                        # print(&#34;-----------------&#34;)
                        # print(&#34;miniPsi:&#34;, miniPsi)
                        # print(&#34;miniMu:&#34;, miniMu)
                        lit = self.__executeLiteral(miniPsi, miniMu)

                        if self.__interpreter.sat(lit[1]):

                            if not (lit[0] is None):
                                if (disRes is None):
                                    disRes = lit[0]
                                    res = lit[1]
                                elif (disRes &gt; lit[0]):
                                    disRes = lit[0]
                                    res = lit[1]
                            else:
                                if (disRes is None) &amp; (res is None):
                                    res = lit[1]
                        else:
                            print(&#34;\nWarning: one revised litteral isn&#39;t satisfiable, consider using a bigger Epsilon value for the distance function.\n&#34;)

                        if self.__verbose:
                            pbar.update(1)

        else:

            setRes = set()
            
            with ExitStack() as stack:

                if self.__verbose:
                    pbar = stack.enter_context(tqdm(total=maxIter, desc=f&#34;{self.getTime()} Revision of every combination&#34;, mininterval=0.5))

                for miniPsi in satPsi:
                    for miniMu in satMu:
                                            
                        lit = self.__executeLiteral(miniPsi, miniMu)
                        
                        if not (lit[0] is None):
                            if (disRes is None):
                                disRes = lit[0]
                                setRes = {lit[1]}
                            elif (disRes == lit[0]):
                                setRes.add(lit[1])
                            elif (disRes &gt; lit[0]):
                                disRes = lit[0]
                                setRes = {lit[1]}
                        else:
                            if (disRes is None):
                                setRes.add(lit[1])

                        if self.__verbose:
                            pbar.update(1)

            res = Or(*setRes).toDNF()

        return (disRes, self.__interpreter.simplifyMLC(res.toLessOrEqConstraint().toDNF()))
    
    def __executeLiteral(self, psi: Formula, mu: Formula) -&gt; tuple[Fraction, Formula]:
        
        epsilon = self.__distance._epsilon

        # second step: find dStar (and psiPrime if onlyOneSoltuion)
        dStar, psiPrime = self.__executeConstraint(self.__interpreter.removeNot(psi), self.__interpreter.removeNot(mu))

        # third step: lambdaEpsilon
        if dStar % epsilon == 0:
            lambdaEpsilon = dStar
        else:
            lambdaEpsilon = epsilon * math.ceil(dStar / epsilon)
            
        # print(lambdaEpsilon, psiPrime)
        # fourth step: find psiPrime (only if not onlyOneSolution)
        if(not self._onlyOneSolution):
            psiPrime = self.__expand(psi, lambdaEpsilon)
    
        # fifth step
        if dStar % epsilon != 0:
            # print(&#34;dStar % epsilon != 0&#34;)
            if self._onlyOneSolution &amp; (not self.__interpreter.sat(psiPrime &amp; mu)):
                psiPrime = self.__interpreter.optimizeCoupleWithLimit(self.__interpreter.removeNot(psi, epsilon), self.__interpreter.removeNot(mu, epsilon), lambdaEpsilon)[1]
            # print(&#34;psiPrime2:&#34;, psiPrime)
            return (lambdaEpsilon, psiPrime &amp; mu)
        elif self.__interpreter.sat(psiPrime &amp; mu):
            return (dStar, psiPrime &amp; mu)
        else:
            # print(&#34;else&#34;)
            lambdaEpsilon = dStar + epsilon
            if (self._onlyOneSolution):
                psiPrime = self.__interpreter.optimizeCoupleWithLimit(self.__interpreter.removeNot(psi, epsilon), self.__interpreter.removeNot(mu, epsilon), lambdaEpsilon)[1]
            else:
                psiPrime = self.__expand(psi, lambdaEpsilon)
            # print(&#34;psiPrime2:&#34;, psiPrime)
            return(dStar, psiPrime &amp; mu)
    
    def __executeConstraint(self, phi: Formula, mu: Formula) -&gt; tuple[Fraction, Formula]:
        return self.__interpreter.optimizeCouple(phi, mu)
    
    def __convertExplicit(self, phi: Formula) -&gt; Formula:
        
        if isinstance(phi, And):
            return Or(phi)
        elif isinstance(phi, UnaryFormula) | isinstance(phi, NullaryFormula):
            return Or(And(phi))
        else:
            orSet = set()
            for miniPhi in phi.children:
                if isinstance(miniPhi, And):
                    orSet.add(miniPhi)
                else:
                    orSet.add(And(miniPhi))
            return Or(*orSet)

    def __expand(self, psi: Formula, lambdaEpsilon: Fraction) -&gt; Formula:
        
        yVariables = {v: v.__class__.declareAnonymous(ending = (&#34;y&#34; + str(v.name))) for v in psi.getVariables()}

        constraints = list()

        # Create x in M(psi) constraints and change variables
        for miniPsi in psi.children:
            if isinstance(miniPsi, Not):
                const = miniPsi.children.clone()
                iterVar = const.variables.copy()
                for key in iterVar:
                    const.variables[yVariables[key]] = const.variables[key]
                    del const.variables[key]
                constraints.append(Not(const))
            else:
                const = miniPsi.clone()
                iterVar = const.variables.copy()
                for key in iterVar:
                    const.variables[yVariables[key]] = const.variables[key]
                    del const.variables[key]
                constraints.append(const)

        # Add distance function constraints
        zVariables = {v: v.__class__.declareAnonymous(ending = (&#34;z&#34; + str(v.name))) for v in psi.getVariables()}
        for yVar in yVariables:
            z = zVariables[yVar]
            # Creating link between x, y and z
            const = LinearConstraint(&#34;&#34;)
            const.variables[yVar] = Fraction(-1)
            const.variables[yVariables[yVar]] = Fraction(1)
            const.variables[z] = Fraction(-1)
            const.operator = ConstraintOperator.LEQ
            const.bound = Fraction(0)
            constraints.append(const)
            const = LinearConstraint(&#34;&#34;)
            const.variables[yVar] = Fraction(1)
            const.variables[yVariables[yVar]] = Fraction(-1)
            const.variables[z] = Fraction(-1)
            const.operator = ConstraintOperator.LEQ
            const.bound = Fraction(0)
            constraints.append(const)
            # Keeping z in memory
            zVariables[yVar] = z

        # TODO pas sûr de mon code, à tester
        # TODO fonction de distance, les poids ?
        # Generate distance constraint
        distanceConstraint = LinearConstraint(&#34;&#34;)
        distanceConstraint.operator = ConstraintOperator.LEQ
        distanceConstraint.bound = lambdaEpsilon
        for z in zVariables:
            distanceConstraint.variables[zVariables[z]] = self.__distance.getWeights()[z]
        constraints.append(distanceConstraint)

        expandConstraint = And(*constraints)

        return self.__projector.projectOn(expandConstraint, yVariables.keys())
    
    def getTime(self):

        timeNow = time.perf_counter()-self.__timeStart
        m = int(timeNow//60)

        s = timeNow%60
        sbfr = int(s)
        saftr = int((s-sbfr)*1000)

        return &#34;{:0&gt;2d}m{:0&gt;2d}.{:0&gt;3d}s |&#34;.format(m, sbfr, saftr)
    
    def organizedPrintResult(self, res):

        variables = list()

        if self._onlyOneSolution:
            
            resAnd = None
            if len(res.children) &gt; 1:
                raise AttributeError(&#34;res isn&#39;t a \&#34;onlyoneSolution\&#34;&#34;)
            else:
                for formula in res.children:
                    resAnd = formula

            for const in resAnd.children:

                lc = const.clone()

                if not lc.operator == ConstraintOperator.EQ:
                    # TODO, min/max pour déterminer bound de chaque variable
                    raise AttributeError(&#34;Can&#39;t print (yet) if not EQ&#34;)
                elif len(lc.variables) &gt; 1:
                    raise AttributeError(&#34;Can&#39;t print (yet) if more than one variable per constraint&#34;)
                else:
                    var = lc.variables.popitem()
                    if (var[0].name[0:4] != &#34;b2i_&#34;) &amp; (not var[0].name[1].isnumeric()):
                        variables.append((var[0], lc.bound / var[1])) # Taking coefficients into account, even though it should always be 1

            maxVarLength = max([len(var[0].name) for var in variables])

            for var, value in sorted(variables, key=lambda x: x[0].name.lower()):

                if isinstance(var, IntegerVariable):
                    print(var.name.rjust(maxVarLength) + &#34; =&#34;, int(value))
                else:
                    print(var.name.rjust(maxVarLength) + &#34; =&#34;, float(value))

            print(&#34;&#34;)

        else:
            raise NotImplementedError(&#34;&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.revision.Revision"><code class="flex name class">
<span>class <span class="ident">Revision</span></span>
<span>(</span><span>solverInit: MLOSolver, distance: DistanceFunction, simplifiers: list[Simplificator] = [], onlyOneSolution: bool = True, verbose: bool = True, projector: Projector = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Main class of the module, allowing the user to make the knowledge revision between two <code><a title="src.formula.formula.Formula" href="formula/formula.html#src.formula.formula.Formula">Formula</a></code>
<span><span class="MathJax_Preview">\psi</span><script type="math/tex">\psi</script></span> and <span><span class="MathJax_Preview">\mu</span><script type="math/tex">\mu</script></span> that are mixed integer linear constraints.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>solverInit</code></strong> :&ensp;<code><a title="src.mlo_solver.MLOSolver.MLOSolver" href="mlo_solver/MLOSolver.html#src.mlo_solver.MLOSolver.MLOSolver">MLOSolver</a></code></dt>
<dd>The solver that will be used for optimization.</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code><a title="src.distance.distance_function.distanceFunction.DistanceFunction" href="distance/distance_function/distanceFunction.html#src.distance.distance_function.distanceFunction.DistanceFunction">DistanceFunction</a></code></dt>
<dd>The distance function that will be used and, more importantly, the weights <span><span class="MathJax_Preview">(w_i)</span><script type="math/tex">(w_i)</script></span> and <span><span class="MathJax_Preview">\varepsilon</span><script type="math/tex">\varepsilon</script></span> arguments of it.
The original algorithm is meant to be used with a <code><a title="src.distance.distance_function.discreteL1DistanceFunction.discreteL1DistanceFunction" href="distance/distance_function/discreteL1DistanceFunction.html#src.distance.distance_function.discreteL1DistanceFunction.discreteL1DistanceFunction">discreteL1DistanceFunction</a></code>.</dd>
<dt><strong><code>simplifiers</code></strong> :&ensp;<code>list</code> of <code><a title="src.simplificator.simplificator.Simplificator" href="simplificator/simplificator.html#src.simplificator.simplificator.Simplificator">Simplificator</a></code>, optional</dt>
<dd>List of all of the <code><a title="src.simplificator.simplificator.Simplificator" href="simplificator/simplificator.html#src.simplificator.simplificator.Simplificator">Simplificator</a></code> that will be applied to the <code><a title="src.formula.formula.Formula" href="formula/formula.html#src.formula.formula.Formula">Formula</a></code>,
in order given by the list.</dd>
<dt><strong><code>onlyOneSolution</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>If set to <code>True</code>, the revision algorithm will by default only return one point that satisfies <span><span class="MathJax_Preview">\psi \circ \mu</span><script type="math/tex">\psi \circ \mu</script></span>.
If not, it will return all solutions.
By default, this constant is set to whichever one was chosen in <code><a title="src.constants.Constants" href="constants.html#src.constants.Constants">Constants</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Revision:
    r&#34;&#34;&#34;
    Main class of the module, allowing the user to make the knowledge revision between two `src.formula.formula.Formula`
    \(\psi\) and \(\mu\) that are mixed integer linear constraints.

    Parameters
    ----------
    solverInit : src.mlo_solver.MLOSolver.MLOSolver
        The solver that will be used for optimization.
    distance : src.distance.distance_function.distanceFunction.DistanceFunction
        The distance function that will be used and, more importantly, the weights \((w_i)\) and \(\varepsilon\) arguments of it.
        The original algorithm is meant to be used with a `src.distance.distance_function.discreteL1DistanceFunction.discreteL1DistanceFunction`.
    simplifiers : list of src.simplificator.simplificator.Simplificator, optional
        List of all of the `src.simplificator.simplificator.Simplificator` that will be applied to the `src.formula.formula.Formula`, 
        in order given by the list.
    onlyOneSolution : boolean, optional
        If set to `True`, the revision algorithm will by default only return one point that satisfies \(\psi \circ \mu\).
        If not, it will return all solutions.
        By default, this constant is set to whichever one was chosen in `src.constants.Constants`.
    &#34;&#34;&#34;
    
    __distance : DistanceFunction
    __interpreter : FormulaInterpreter
    __e2bConstraints: set[Formula]
    _onlyOneSolution: bool

    def __init__(self, solverInit : MLOSolver, distance : DistanceFunction, simplifiers : list[Simplificator] = [], onlyOneSolution: bool = Constants.ONLY_ONE_SOLUTION, verbose: bool = Constants.SET_VERBOSE, projector: Projector = None) -&gt; None:        
        self.__distance = distance 
        self.__interpreter = FormulaInterpreter(solverInit, distance, simplifiers)
        self._onlyOneSolution = onlyOneSolution
        self.__verbose = verbose

        self.__e2bConstraints = set()

        self.__projector = projector

    def preload(self):

        weights = self.__distance.getWeights()
        self.boolToInt = dict()

        for var in weights.copy().keys():

            if isinstance(var, PropositionalVariable):
                self.__b2iPreload(var, weights)

            if isinstance(var, EnumeratedType):

                self.__e2bConstraints.add(var.generateConstraints())

                for value in var.values.values():
                    weights[value] = weights[var]
                    self.__b2iPreload(value, weights)

    def __b2iPreload(self, var, weights):

        intVar = IntegerVariable.declare(&#34;b2i_&#34; + var.name, lowerBound=Fraction(0), upperBound=Fraction(1))

        self.boolToInt[var] = intVar
        weights[intVar] = weights[var]

    def execute(self, psi : Formula, mu : Formula) -&gt; tuple[Fraction, Formula]:
        r&#34;&#34;&#34;
        Execute the revision of \(\psi\) by \(\mu\).

        Parameters
        ----------
        psi : src.formula.formula.Formula
            \(\psi\), left part of the knowledge revision operator and `src.formula.formula.Formula` that will be revised.
        mu : src.formula.formula.Formula
            \(\mu\), right part of the knowledge revision operator and `src.formula.formula.Formula` that will be used to revise \(\psi\) by.


        Returns
        -------
        Fraction
            Distance (calculated with the `src.distance.distance_function.distanceFunction.DistanceFunction`
            given at the initialization of the class) between \(\psi\) and \(\mu\).
        src.formula.formula.Formula
            Result of the knowledge revison of \(\psi\) by \(\mu\).
        &#34;&#34;&#34;

        self.__timeStart = time.perf_counter()

        if len(self.__e2bConstraints) &gt;= 1:
            psi &amp;= And(*self.__e2bConstraints)
            mu &amp;= And(*self.__e2bConstraints)

        if self.__verbose:
            print(&#34;\n&#34; + self.getTime(), &#34;Transforming Psi in DNF form&#34;)
        psiDNF = psi.toPCMLC(self.boolToInt).toLessOrEqConstraint().toDNF()

        if self.__verbose:
            print(&#34;\n&#34; + self.getTime(), &#34;Transforming Mu in DNF form&#34;)
        muDNF = mu.toPCMLC(self.boolToInt).toLessOrEqConstraint().toDNF()

        res = self.__executeDNF(self.__convertExplicit(psiDNF), self.__convertExplicit(muDNF))

        if self.__verbose:
            print(&#34;\n&#34; + self.getTime(), f&#34;Solution found with distance of {res[0]}:\n&#34;)
            try:
                self.organizedPrintResult(res[1])
            except:
                print(res[1])

        return res
        
    def __executeDNF(self, psi: Formula, mu: Formula) -&gt; tuple[Fraction, Formula]:
        
        res = None
        disRes = None

        if self.__verbose:
            print(&#34;&#34;)
            psiIter = tqdm(psi.children, desc=f&#34;{self.getTime()} Testing satisfiability of every child of Psi&#34;, mininterval=0.5)
        else:
            psiIter = psi.children

        satPsi = set()
        for miniPsi in psiIter:
            if self.__interpreter.sat(miniPsi):
                satPsi.add(miniPsi)

        if len(satPsi) == 0:
            raise(AttributeError(&#34;Psi is not satisfiable&#34;))

        if self.__verbose:
            print(self.getTime(), f&#34;{len(satPsi)} satisfiable children of Psi found\n&#34;)
            muIter = tqdm(mu.children, desc=f&#34;{self.getTime()} Testing satisfiability of every child of Mu&#34;, mininterval=0.5)
        else:
            muIter = mu.children
            
        satMu = set()
        for miniMu in muIter:
            if self.__interpreter.sat(miniMu):
                satMu.add(miniMu)

        if len(satMu) == 0:
            raise(AttributeError(&#34;Mu is not satisfiable&#34;))

        maxIter = len(satPsi)*len(satMu)

        if self.__verbose:
            print(self.getTime(), f&#34;{len(satMu)} satisfiable children of Mu found&#34;)
            print(&#34;\n&#34; + self.getTime(), f&#34;{maxIter} combinations of conjunctions found&#34;)

        if(self._onlyOneSolution):

            with ExitStack() as stack:

                if self.__verbose:
                    pbar = stack.enter_context(tqdm(total=maxIter, desc=f&#34;{self.getTime()} Revision of every combination&#34;, mininterval=0.5))

                for miniPsi in satPsi:
                    for miniMu in satMu:

                        # print(&#34;-----------------&#34;)
                        # print(&#34;miniPsi:&#34;, miniPsi)
                        # print(&#34;miniMu:&#34;, miniMu)
                        lit = self.__executeLiteral(miniPsi, miniMu)

                        if self.__interpreter.sat(lit[1]):

                            if not (lit[0] is None):
                                if (disRes is None):
                                    disRes = lit[0]
                                    res = lit[1]
                                elif (disRes &gt; lit[0]):
                                    disRes = lit[0]
                                    res = lit[1]
                            else:
                                if (disRes is None) &amp; (res is None):
                                    res = lit[1]
                        else:
                            print(&#34;\nWarning: one revised litteral isn&#39;t satisfiable, consider using a bigger Epsilon value for the distance function.\n&#34;)

                        if self.__verbose:
                            pbar.update(1)

        else:

            setRes = set()
            
            with ExitStack() as stack:

                if self.__verbose:
                    pbar = stack.enter_context(tqdm(total=maxIter, desc=f&#34;{self.getTime()} Revision of every combination&#34;, mininterval=0.5))

                for miniPsi in satPsi:
                    for miniMu in satMu:
                                            
                        lit = self.__executeLiteral(miniPsi, miniMu)
                        
                        if not (lit[0] is None):
                            if (disRes is None):
                                disRes = lit[0]
                                setRes = {lit[1]}
                            elif (disRes == lit[0]):
                                setRes.add(lit[1])
                            elif (disRes &gt; lit[0]):
                                disRes = lit[0]
                                setRes = {lit[1]}
                        else:
                            if (disRes is None):
                                setRes.add(lit[1])

                        if self.__verbose:
                            pbar.update(1)

            res = Or(*setRes).toDNF()

        return (disRes, self.__interpreter.simplifyMLC(res.toLessOrEqConstraint().toDNF()))
    
    def __executeLiteral(self, psi: Formula, mu: Formula) -&gt; tuple[Fraction, Formula]:
        
        epsilon = self.__distance._epsilon

        # second step: find dStar (and psiPrime if onlyOneSoltuion)
        dStar, psiPrime = self.__executeConstraint(self.__interpreter.removeNot(psi), self.__interpreter.removeNot(mu))

        # third step: lambdaEpsilon
        if dStar % epsilon == 0:
            lambdaEpsilon = dStar
        else:
            lambdaEpsilon = epsilon * math.ceil(dStar / epsilon)
            
        # print(lambdaEpsilon, psiPrime)
        # fourth step: find psiPrime (only if not onlyOneSolution)
        if(not self._onlyOneSolution):
            psiPrime = self.__expand(psi, lambdaEpsilon)
    
        # fifth step
        if dStar % epsilon != 0:
            # print(&#34;dStar % epsilon != 0&#34;)
            if self._onlyOneSolution &amp; (not self.__interpreter.sat(psiPrime &amp; mu)):
                psiPrime = self.__interpreter.optimizeCoupleWithLimit(self.__interpreter.removeNot(psi, epsilon), self.__interpreter.removeNot(mu, epsilon), lambdaEpsilon)[1]
            # print(&#34;psiPrime2:&#34;, psiPrime)
            return (lambdaEpsilon, psiPrime &amp; mu)
        elif self.__interpreter.sat(psiPrime &amp; mu):
            return (dStar, psiPrime &amp; mu)
        else:
            # print(&#34;else&#34;)
            lambdaEpsilon = dStar + epsilon
            if (self._onlyOneSolution):
                psiPrime = self.__interpreter.optimizeCoupleWithLimit(self.__interpreter.removeNot(psi, epsilon), self.__interpreter.removeNot(mu, epsilon), lambdaEpsilon)[1]
            else:
                psiPrime = self.__expand(psi, lambdaEpsilon)
            # print(&#34;psiPrime2:&#34;, psiPrime)
            return(dStar, psiPrime &amp; mu)
    
    def __executeConstraint(self, phi: Formula, mu: Formula) -&gt; tuple[Fraction, Formula]:
        return self.__interpreter.optimizeCouple(phi, mu)
    
    def __convertExplicit(self, phi: Formula) -&gt; Formula:
        
        if isinstance(phi, And):
            return Or(phi)
        elif isinstance(phi, UnaryFormula) | isinstance(phi, NullaryFormula):
            return Or(And(phi))
        else:
            orSet = set()
            for miniPhi in phi.children:
                if isinstance(miniPhi, And):
                    orSet.add(miniPhi)
                else:
                    orSet.add(And(miniPhi))
            return Or(*orSet)

    def __expand(self, psi: Formula, lambdaEpsilon: Fraction) -&gt; Formula:
        
        yVariables = {v: v.__class__.declareAnonymous(ending = (&#34;y&#34; + str(v.name))) for v in psi.getVariables()}

        constraints = list()

        # Create x in M(psi) constraints and change variables
        for miniPsi in psi.children:
            if isinstance(miniPsi, Not):
                const = miniPsi.children.clone()
                iterVar = const.variables.copy()
                for key in iterVar:
                    const.variables[yVariables[key]] = const.variables[key]
                    del const.variables[key]
                constraints.append(Not(const))
            else:
                const = miniPsi.clone()
                iterVar = const.variables.copy()
                for key in iterVar:
                    const.variables[yVariables[key]] = const.variables[key]
                    del const.variables[key]
                constraints.append(const)

        # Add distance function constraints
        zVariables = {v: v.__class__.declareAnonymous(ending = (&#34;z&#34; + str(v.name))) for v in psi.getVariables()}
        for yVar in yVariables:
            z = zVariables[yVar]
            # Creating link between x, y and z
            const = LinearConstraint(&#34;&#34;)
            const.variables[yVar] = Fraction(-1)
            const.variables[yVariables[yVar]] = Fraction(1)
            const.variables[z] = Fraction(-1)
            const.operator = ConstraintOperator.LEQ
            const.bound = Fraction(0)
            constraints.append(const)
            const = LinearConstraint(&#34;&#34;)
            const.variables[yVar] = Fraction(1)
            const.variables[yVariables[yVar]] = Fraction(-1)
            const.variables[z] = Fraction(-1)
            const.operator = ConstraintOperator.LEQ
            const.bound = Fraction(0)
            constraints.append(const)
            # Keeping z in memory
            zVariables[yVar] = z

        # TODO pas sûr de mon code, à tester
        # TODO fonction de distance, les poids ?
        # Generate distance constraint
        distanceConstraint = LinearConstraint(&#34;&#34;)
        distanceConstraint.operator = ConstraintOperator.LEQ
        distanceConstraint.bound = lambdaEpsilon
        for z in zVariables:
            distanceConstraint.variables[zVariables[z]] = self.__distance.getWeights()[z]
        constraints.append(distanceConstraint)

        expandConstraint = And(*constraints)

        return self.__projector.projectOn(expandConstraint, yVariables.keys())
    
    def getTime(self):

        timeNow = time.perf_counter()-self.__timeStart
        m = int(timeNow//60)

        s = timeNow%60
        sbfr = int(s)
        saftr = int((s-sbfr)*1000)

        return &#34;{:0&gt;2d}m{:0&gt;2d}.{:0&gt;3d}s |&#34;.format(m, sbfr, saftr)
    
    def organizedPrintResult(self, res):

        variables = list()

        if self._onlyOneSolution:
            
            resAnd = None
            if len(res.children) &gt; 1:
                raise AttributeError(&#34;res isn&#39;t a \&#34;onlyoneSolution\&#34;&#34;)
            else:
                for formula in res.children:
                    resAnd = formula

            for const in resAnd.children:

                lc = const.clone()

                if not lc.operator == ConstraintOperator.EQ:
                    # TODO, min/max pour déterminer bound de chaque variable
                    raise AttributeError(&#34;Can&#39;t print (yet) if not EQ&#34;)
                elif len(lc.variables) &gt; 1:
                    raise AttributeError(&#34;Can&#39;t print (yet) if more than one variable per constraint&#34;)
                else:
                    var = lc.variables.popitem()
                    if (var[0].name[0:4] != &#34;b2i_&#34;) &amp; (not var[0].name[1].isnumeric()):
                        variables.append((var[0], lc.bound / var[1])) # Taking coefficients into account, even though it should always be 1

            maxVarLength = max([len(var[0].name) for var in variables])

            for var, value in sorted(variables, key=lambda x: x[0].name.lower()):

                if isinstance(var, IntegerVariable):
                    print(var.name.rjust(maxVarLength) + &#34; =&#34;, int(value))
                else:
                    print(var.name.rjust(maxVarLength) + &#34; =&#34;, float(value))

            print(&#34;&#34;)

        else:
            raise NotImplementedError(&#34;&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.revision.Revision.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, psi: Formula, mu: Formula) ‑> tuple[fractions.Fraction, <a title="src.formula.formula.Formula" href="formula/formula.html#src.formula.formula.Formula">Formula</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the revision of <span><span class="MathJax_Preview">\psi</span><script type="math/tex">\psi</script></span> by <span><span class="MathJax_Preview">\mu</span><script type="math/tex">\mu</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>psi</code></strong> :&ensp;<code><a title="src.formula.formula.Formula" href="formula/formula.html#src.formula.formula.Formula">Formula</a></code></dt>
<dd><span><span class="MathJax_Preview">\psi</span><script type="math/tex">\psi</script></span>, left part of the knowledge revision operator and <code><a title="src.formula.formula.Formula" href="formula/formula.html#src.formula.formula.Formula">Formula</a></code> that will be revised.</dd>
<dt><strong><code>mu</code></strong> :&ensp;<code><a title="src.formula.formula.Formula" href="formula/formula.html#src.formula.formula.Formula">Formula</a></code></dt>
<dd><span><span class="MathJax_Preview">\mu</span><script type="math/tex">\mu</script></span>, right part of the knowledge revision operator and <code><a title="src.formula.formula.Formula" href="formula/formula.html#src.formula.formula.Formula">Formula</a></code> that will be used to revise <span><span class="MathJax_Preview">\psi</span><script type="math/tex">\psi</script></span> by.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Fraction</code></dt>
<dd>Distance (calculated with the <code><a title="src.distance.distance_function.distanceFunction.DistanceFunction" href="distance/distance_function/distanceFunction.html#src.distance.distance_function.distanceFunction.DistanceFunction">DistanceFunction</a></code>
given at the initialization of the class) between <span><span class="MathJax_Preview">\psi</span><script type="math/tex">\psi</script></span> and <span><span class="MathJax_Preview">\mu</span><script type="math/tex">\mu</script></span>.</dd>
<dt><code><a title="src.formula.formula.Formula" href="formula/formula.html#src.formula.formula.Formula">Formula</a></code></dt>
<dd>Result of the knowledge revison of <span><span class="MathJax_Preview">\psi</span><script type="math/tex">\psi</script></span> by <span><span class="MathJax_Preview">\mu</span><script type="math/tex">\mu</script></span>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, psi : Formula, mu : Formula) -&gt; tuple[Fraction, Formula]:
    r&#34;&#34;&#34;
    Execute the revision of \(\psi\) by \(\mu\).

    Parameters
    ----------
    psi : src.formula.formula.Formula
        \(\psi\), left part of the knowledge revision operator and `src.formula.formula.Formula` that will be revised.
    mu : src.formula.formula.Formula
        \(\mu\), right part of the knowledge revision operator and `src.formula.formula.Formula` that will be used to revise \(\psi\) by.


    Returns
    -------
    Fraction
        Distance (calculated with the `src.distance.distance_function.distanceFunction.DistanceFunction`
        given at the initialization of the class) between \(\psi\) and \(\mu\).
    src.formula.formula.Formula
        Result of the knowledge revison of \(\psi\) by \(\mu\).
    &#34;&#34;&#34;

    self.__timeStart = time.perf_counter()

    if len(self.__e2bConstraints) &gt;= 1:
        psi &amp;= And(*self.__e2bConstraints)
        mu &amp;= And(*self.__e2bConstraints)

    if self.__verbose:
        print(&#34;\n&#34; + self.getTime(), &#34;Transforming Psi in DNF form&#34;)
    psiDNF = psi.toPCMLC(self.boolToInt).toLessOrEqConstraint().toDNF()

    if self.__verbose:
        print(&#34;\n&#34; + self.getTime(), &#34;Transforming Mu in DNF form&#34;)
    muDNF = mu.toPCMLC(self.boolToInt).toLessOrEqConstraint().toDNF()

    res = self.__executeDNF(self.__convertExplicit(psiDNF), self.__convertExplicit(muDNF))

    if self.__verbose:
        print(&#34;\n&#34; + self.getTime(), f&#34;Solution found with distance of {res[0]}:\n&#34;)
        try:
            self.organizedPrintResult(res[1])
        except:
            print(res[1])

    return res</code></pre>
</details>
</dd>
<dt id="src.revision.Revision.getTime"><code class="name flex">
<span>def <span class="ident">getTime</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTime(self):

    timeNow = time.perf_counter()-self.__timeStart
    m = int(timeNow//60)

    s = timeNow%60
    sbfr = int(s)
    saftr = int((s-sbfr)*1000)

    return &#34;{:0&gt;2d}m{:0&gt;2d}.{:0&gt;3d}s |&#34;.format(m, sbfr, saftr)</code></pre>
</details>
</dd>
<dt id="src.revision.Revision.organizedPrintResult"><code class="name flex">
<span>def <span class="ident">organizedPrintResult</span></span>(<span>self, res)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def organizedPrintResult(self, res):

    variables = list()

    if self._onlyOneSolution:
        
        resAnd = None
        if len(res.children) &gt; 1:
            raise AttributeError(&#34;res isn&#39;t a \&#34;onlyoneSolution\&#34;&#34;)
        else:
            for formula in res.children:
                resAnd = formula

        for const in resAnd.children:

            lc = const.clone()

            if not lc.operator == ConstraintOperator.EQ:
                # TODO, min/max pour déterminer bound de chaque variable
                raise AttributeError(&#34;Can&#39;t print (yet) if not EQ&#34;)
            elif len(lc.variables) &gt; 1:
                raise AttributeError(&#34;Can&#39;t print (yet) if more than one variable per constraint&#34;)
            else:
                var = lc.variables.popitem()
                if (var[0].name[0:4] != &#34;b2i_&#34;) &amp; (not var[0].name[1].isnumeric()):
                    variables.append((var[0], lc.bound / var[1])) # Taking coefficients into account, even though it should always be 1

        maxVarLength = max([len(var[0].name) for var in variables])

        for var, value in sorted(variables, key=lambda x: x[0].name.lower()):

            if isinstance(var, IntegerVariable):
                print(var.name.rjust(maxVarLength) + &#34; =&#34;, int(value))
            else:
                print(var.name.rjust(maxVarLength) + &#34; =&#34;, float(value))

        print(&#34;&#34;)

    else:
        raise NotImplementedError(&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="src.revision.Revision.preload"><code class="name flex">
<span>def <span class="ident">preload</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preload(self):

    weights = self.__distance.getWeights()
    self.boolToInt = dict()

    for var in weights.copy().keys():

        if isinstance(var, PropositionalVariable):
            self.__b2iPreload(var, weights)

        if isinstance(var, EnumeratedType):

            self.__e2bConstraints.add(var.generateConstraints())

            for value in var.values.values():
                weights[value] = weights[var]
                self.__b2iPreload(value, weights)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.revision.Revision" href="#src.revision.Revision">Revision</a></code></h4>
<ul class="">
<li><code><a title="src.revision.Revision.execute" href="#src.revision.Revision.execute">execute</a></code></li>
<li><code><a title="src.revision.Revision.getTime" href="#src.revision.Revision.getTime">getTime</a></code></li>
<li><code><a title="src.revision.Revision.organizedPrintResult" href="#src.revision.Revision.organizedPrintResult">organizedPrintResult</a></code></li>
<li><code><a title="src.revision.Revision.preload" href="#src.revision.Revision.preload">preload</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>